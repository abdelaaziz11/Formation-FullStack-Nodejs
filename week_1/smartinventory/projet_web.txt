
🏛️ Architecture du Projet
Le projet suivra la structure de dossiers et de fichiers demandée pour garantir une bonne séparation des responsabilités.

Plaintext
smartinventory/
├── data/
│   ├── products.json
│   └── orders.json
├── src/
│   ├── controllers/
│   │   ├── healthController.js
│   │   ├── ordersController.js
│   │   └── productsController.js
│   ├── services/
│   │   ├── ordersService.js
│   │   └── productsService.js
│   ├── utils/
│   │   ├── logger.js
│   │   └── sendJson.js
│   ├── router.js
│   └── server.js
├── .env.sample
├── package.json
└── README.md
📦 Fichiers de Données et Configuration
Commençons par créer les fichiers de données et de configuration.

1. Données (data/)
Créez deux fichiers JSON avec quelques données d'exemple.

data/products.json
JSON
[
  {
    "id": 1,
    "sku": "SKU-001",
    "name": "Marteau robuste",
    "description": "Un marteau de haute qualité pour tous vos besoins.",
    "price": 25.99,
    "category": "tools",
    "inStock": true,
    "stock": 150
  },
  {
    "id": 2,
    "sku": "SKU-002",
    "name": "Tournevis cruciforme",
    "description": "Tournevis avec poignée ergonomique.",
    "price": 8.50,
    "category": "tools",
    "inStock": true,
    "stock": 300
  },
  {
    "id": 3,
    "sku": "SKU-003",
    "name": "Clavier mécanique",
    "description": "Clavier rétroéclairé pour le gaming et la productivité.",
    "price": 120.00,
    "category": "electronics",
    "inStock": false,
    "stock": 0
  },
  {
    "id": 4,
    "sku": "SKU-004",
    "name": "Souris sans fil",
    "description": "Souris optique avec une grande autonomie.",
    "price": 45.50,
    "category": "electronics",
    "inStock": true,
    "stock": 80
  }
]
data/orders.json
JSON
[
  {
    "id": 101,
    "orderNumber": "ORD-2025-0001",
    "date": "2025-03-15T10:30:00Z",
    "status": "shipped",
    "total": 34.49,
    "items": [
      { "productId": 1, "quantity": 1 },
      { "productId": 2, "quantity": 1 }
    ]
  },
  {
    "id": 102,
    "orderNumber": "ORD-2025-0002",
    "date": "2025-03-16T14:00:00Z",
    "status": "paid",
    "total": 165.50,
    "items": [
      { "productId": 3, "quantity": 1 },
      { "productId": 4, "quantity": 1 }
    ]
  }
]
2. Configuration (.env.sample)
Ce fichier sert de modèle pour les variables d'environnement.

Ini, TOML
# Port sur lequel le serveur écoutera
PORT=3000
Créez un fichier .env en copiant celui-ci pour que le serveur puisse le lire.

3. Fichier package.json
Ce fichier définit les métadonnées du projet et ses scripts.

JSON
{
  "name": "smartinventory",
  "version": "1.0.0",
  "description": "Serveur Node.js pour servir des données statiques d'inventaire.",
  "main": "src/server.js",
  "scripts": {
    "start": "node src/server.js",
    "dev": "node src/server.js"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "author": "",
  "license": "ISC"
}
💻 Code Source (src/)
Voici le code pour chaque fichier du répertoire src.

1. Utilitaires (src/utils/)
src/utils/logger.js
Ce module utilise EventEmitter pour journaliser les événements de requête et de réponse de manière découplée.

JavaScript
const EventEmitter = require('events');

class Logger extends EventEmitter {
  constructor() {
    super();
    // Écouteur pour l'événement de réception d'une requête
    this.on('request:received', ({ method, url }) => {
      console.log(`[${new Date().toISOString()}] REQ  | ${method} ${url}`);
    });

    // Écouteur pour l'événement d'envoi d'une réponse
    this.on('response:sent', ({ statusCode, route, method, url }) => {
      console.log(`[${new Date().toISOString()}] RESP | ${statusCode} - ${method} ${url} -> ${route}`);
    });
  }
}

// Exporter une seule instance (singleton) du logger
module.exports = new Logger();
src/utils/sendJson.js
Une fonction utilitaire pour centraliser la logique d'envoi des réponses JSON.

JavaScript
/**
 * Envoie une réponse JSON standardisée.
 * @param {http.ServerResponse} res - L'objet de réponse.
 * @param {number} statusCode - Le code de statut HTTP.
 * @param {object} data - L'objet de données à envoyer en JSON.
 */
function sendJson(res, statusCode, data) {
  res.writeHead(statusCode, { 'Content-Type': 'application/json; charset=utf-8' });
  res.end(JSON.stringify(data));
}

module.exports = sendJson;
2. Services (src/services/)
Les services gèrent la logique métier : lire les fichiers, filtrer et paginer les données.

src/services/productsService.js
JavaScript
const fs = require('fs/promises');
const path = require('path');

const dataPath = path.join(__dirname, '..', '..', 'data', 'products.json');

// Cache simple en mémoire pour éviter les lectures disque répétées
let productsCache = null;

async function readProductsFile() {
  if (productsCache) {
    return productsCache;
  }
  try {
    const data = await fs.readFile(dataPath, 'utf-8');
    productsCache = JSON.parse(data);
    return productsCache;
  } catch (error) {
    // Si le fichier n'existe pas ou est corrompu, on lance une erreur
    console.error("Erreur de lecture ou de parsing du fichier products.json:", error);
    throw new Error("Impossible de charger les données des produits.");
  }
}

async function getAllProducts(query) {
  let products = await readProductsFile();

  // Filtrage
  if (query.q) {
    const searchTerm = query.q.toLowerCase();
    products = products.filter(p => p.name.toLowerCase().includes(searchTerm) || p.description.toLowerCase().includes(searchTerm));
  }
  if (query.category) {
    products = products.filter(p => p.category.toLowerCase() === query.category.toLowerCase());
  }
  if (query.minPrice) {
    products = products.filter(p => p.price >= parseFloat(query.minPrice));
  }
  if (query.maxPrice) {
    products = products.filter(p => p.price <= parseFloat(query.maxPrice));
  }
  if (query.inStock) {
    const inStock = query.inStock === 'true';
    products = products.filter(p => p.inStock === inStock);
  }

  const total = products.length;

  // Pagination
  const page = parseInt(query.page, 10) || 1;
  const limit = parseInt(query.limit, 10) || 10;
  const startIndex = (page - 1) * limit;
  const endIndex = page * limit;

  const paginatedProducts = products.slice(startIndex, endIndex);

  return {
    total,
    page,
    pages: Math.ceil(total / limit),
    data: paginatedProducts,
  };
}

async function getProductById(id) {
  const products = await readProductsFile();
  return products.find(p => p.id === parseInt(id, 10));
}

async function getProductBySku(sku) {
  const products = await readProductsFile();
  return products.find(p => p.sku === sku);
}

module.exports = { getAllProducts, getProductById, getProductBySku };
src/services/ordersService.js
JavaScript
const fs = require('fs/promises');
const path = require('path');

const dataPath = path.join(__dirname, '..', '..', 'data', 'orders.json');
let ordersCache = null;

async function readOrdersFile() {
  if (ordersCache) {
    return ordersCache;
  }
  try {
    const data = await fs.readFile(dataPath, 'utf-8');
    ordersCache = JSON.parse(data);
    return ordersCache;
  } catch (error) {
    console.error("Erreur de lecture ou de parsing du fichier orders.json:", error);
    throw new Error("Impossible de charger les données des commandes.");
  }
}

async function getAllOrders(query) {
  let orders = await readOrdersFile();

  // Filtrage
  if (query.status) {
    orders = orders.filter(o => o.status.toLowerCase() === query.status.toLowerCase());
  }
  if (query.from) {
    orders = orders.filter(o => new Date(o.date) >= new Date(query.from));
  }
  if (query.to) {
    orders = orders.filter(o => new Date(o.date) <= new Date(query.to));
  }

  const total = orders.length;

  // Pagination
  const page = parseInt(query.page, 10) || 1;
  const limit = parseInt(query.limit, 10) || 10;
  const startIndex = (page - 1) * limit;
  const endIndex = page * limit;

  const paginatedOrders = orders.slice(startIndex, endIndex);

  return {
    total,
    page,
    pages: Math.ceil(total / limit),
    data: paginatedOrders,
  };
}

async function getOrderById(id) {
  const orders = await readOrdersFile();
  return orders.find(o => o.id === parseInt(id, 10));
}

async function getOrderByNumber(orderNumber) {
  const orders = await readOrdersFile();
  return orders.find(o => o.orderNumber === orderNumber);
}

module.exports = { getAllOrders, getOrderById, getOrderByNumber };
3. Contrôleurs (src/controllers/)
Les contrôleurs font le lien entre les requêtes HTTP et les services. Ils valident les entrées et formatent les réponses.

src/controllers/productsController.js
JavaScript
const productsService = require('../services/productsService');
const sendJson = require('../utils/sendJson');

async function listProducts(req, res) {
  const { query } = req;
  // Validation simple
  if (query.minPrice && query.maxPrice && parseFloat(query.minPrice) > parseFloat(query.maxPrice)) {
    return sendJson(res, 400, { error: "Query invalide: minPrice ne peut pas être supérieur à maxPrice." });
  }
  try {
    const products = await productsService.getAllProducts(query);
    sendJson(res, 200, products);
  } catch (error) {
    sendJson(res, 500, { error: error.message });
  }
}

async function getProduct(req, res) {
  const { id } = req.params;
  try {
    const product = await productsService.getProductById(id);
    if (!product) {
      return sendJson(res, 404, { error: "Produit non trouvé." });
    }
    sendJson(res, 200, product);
  } catch (error) {
    sendJson(res, 500, { error: error.message });
  }
}

async function getProductBySku(req, res) {
    const { sku } = req.params;
    try {
      const product = await productsService.getProductBySku(sku);
      if (!product) {
        return sendJson(res, 404, { error: "Produit non trouvé pour ce SKU." });
      }
      sendJson(res, 200, product);
    } catch (error) {
      sendJson(res, 500, { error: error.message });
    }
  }

module.exports = { listProducts, getProduct, getProductBySku };
src/controllers/ordersController.js
JavaScript
const ordersService = require('../services/ordersService');
const sendJson = require('../utils/sendJson');

async function listOrders(req, res) {
    const { query } = req;
    // Validation des dates
    if (query.from && query.to && new Date(query.from) > new Date(query.to)) {
        return sendJson(res, 400, { error: "Query invalide: la date 'from' ne peut pas être postérieure à la date 'to'." });
    }
  try {
    const orders = await ordersService.getAllOrders(query);
    sendJson(res, 200, orders);
  } catch (error) {
    sendJson(res, 500, { error: error.message });
  }
}

async function getOrder(req, res) {
  const { id } = req.params;
  try {
    const order = await ordersService.getOrderById(id);
    if (!order) {
      return sendJson(res, 404, { error: "Commande non trouvée." });
    }
    sendJson(res, 200, order);
  } catch (error) {
    sendJson(res, 500, { error: error.message });
  }
}

async function getOrderByNumber(req, res) {
    const { orderNumber } = req.params;
    try {
      const order = await ordersService.getOrderByNumber(orderNumber);
      if (!order) {
        return sendJson(res, 404, { error: "Commande non trouvée pour ce numéro." });
      }
      sendJson(res, 200, order);
    } catch (error) {
      sendJson(res, 500, { error: error.message });
    }
  }

module.exports = { listOrders, getOrder, getOrderByNumber };
src/controllers/healthController.js
JavaScript
const sendJson = require('../utils/sendJson');
const serverStartTime = Date.now();

function getHealth(req, res) {
    const uptime = (Date.now() - serverStartTime) / 1000; // en secondes
    const healthStatus = {
        status: "ok",
        uptime: `${uptime.toFixed(2)}s`,
        timestamp: new Date().toISOString()
    };
    sendJson(res, 200, healthStatus);
}

module.exports = { getHealth };
4. Routeur (src/router.js)
Ce module centralise la logique de routage pour éviter une cascade de if/else. Il analyse l'URL et délègue au bon contrôleur.

JavaScript
const url = require('url');
const sendJson = require('./utils/sendJson');
const logger = require('./utils/logger');

// Import des contrôleurs
const productsController = require('./controllers/productsController');
const ordersController = require('./controllers/ordersController');
const healthController = require('./controllers/healthController');

// Définition des routes
// On utilise des expressions régulières pour capturer les paramètres d'URL
const routes = [
    { method: 'GET', path: /^\/api\/products\/?$/, handler: productsController.listProducts },
    { method: 'GET', path: /^\/api\/products\/([0-9]+)\/?$/, handler: productsController.getProduct, params: ['id'] },
    { method: 'GET', path: /^\/api\/products\/sku\/(.+)\/?$/, handler: productsController.getProductBySku, params: ['sku'] },
    { method: 'GET', path: /^\/api\/orders\/?$/, handler: ordersController.listOrders },
    { method: 'GET', path: /^\/api\/orders\/([0-9]+)\/?$/, handler: ordersController.getOrder, params: ['id'] },
    { method: 'GET', path: /^\/api\/orders\/number\/(.+)\/?$/, handler: ordersController.getOrderByNumber, params: ['orderNumber'] },
    { method: 'GET', path: /^\/health\/?$/, handler: healthController.getHealth },
];

function router(req, res) {
    const parsedUrl = url.parse(req.url, true);
    const { pathname, query } = parsedUrl;
    const { method } = req;

    const matchedRoute = routes.find(route => route.method === method && route.path.test(pathname));
    
    // Enrichir l'objet req avec la query pour un accès facile dans les contrôleurs
    req.query = query;

    if (matchedRoute) {
        const matches = pathname.match(matchedRoute.path);
        // Extraire les paramètres de l'URL (ex: id)
        req.params = {};
        if (matchedRoute.params && matches.length > 1) {
            matchedRoute.params.forEach((paramName, index) => {
                req.params[paramName] = matches[index + 1];
            });
        }
        
        // Log de la réponse après son envoi
        res.on('finish', () => {
            logger.emit('response:sent', {
                statusCode: res.statusCode,
                route: matchedRoute.path.toString(),
                method,
                url: req.url
            });
        });
        
        // Appel du contrôleur associé
        return matchedRoute.handler(req, res);
    }

    // Si aucune route ne correspond
    res.on('finish', () => {
        logger.emit('response:sent', {
            statusCode: res.statusCode,
            route: 'Not Found',
            method,
            url: req.url
        });
    });
    sendJson(res, 404, { error: 'Not Found' });
}

module.exports = router;
5. Serveur (src/server.js)
C'est le point d'entrée de l'application. Il crée le serveur HTTP et utilise le routeur pour gérer les requêtes.

JavaScript
const http = require('http');
const router = require('./router');
const logger = require('./utils/logger');

// Chargement de la configuration du port
// Utilise le port 3000 par défaut si non spécifié dans .env
const PORT = process.env.PORT || 3000;

// Création du serveur
const server = http.createServer((req, res) => {
    // Émission de l'événement de réception de la requête
    logger.emit('request:received', { method: req.method, url: req.url });
    
    // Délégation de la gestion de la requête au routeur
    router(req, res);
});

// Démarrage du serveur
server.listen(PORT, () => {
    console.log(`🚀 Serveur démarré et à l'écoute sur http://localhost:${PORT}`);
});
📖 Documentation (README.md)
Un bon projet a besoin d'une bonne documentation.

Markdown
# Smart Inventory System

Ce projet est un serveur HTTP simple développé en Node.js pur (sans framework) pour servir des données statiques d'inventaire (produits et commandes) via une API RESTful.

## Prérequis

- [Node.js](https://nodejs.org/) (version 18.x ou supérieure)

## Installation

1.  Clonez ce dépôt sur votre machine locale.
2.  Naviguez dans le répertoire du projet :
    ```sh
    cd smartinventory
    ```
3.  Installez les dépendances (même s'il n'y en a pas, c'est une bonne pratique) :
    ```sh
    npm install
    ```
4.  Créez un fichier `.env` à la racine du projet en copiant le fichier `.env.sample`. Vous pouvez y modifier le port si nécessaire.

    ```sh
    cp .env.sample .env
    ```

## Démarrage

Pour lancer le serveur en mode développement (ou production), exécutez la commande suivante :

```sh
npm run dev
```

ou

```sh
npm start
```

Le serveur sera alors accessible à l'adresse `http://localhost:3000` (ou le port que vous avez configuré).

## Exemples d'Utilisation avec cURL

Voici quelques exemples de requêtes que vous pouvez effectuer avec `curl`.

### Point de terminaison de Santé

Vérifie l'état de fonctionnement du serveur.

```sh
curl "http://localhost:3000/health"
```

### API Produits

- **Lister tous les produits avec filtres et pagination :**
  ```sh
  curl "http://localhost:3000/api/products?category=tools&minPrice=10&maxPrice=100&page=1&limit=5"
  ```

- **Obtenir un produit par son ID :**
  ```sh

  curl "http://localhost:3000/api/products/1"
  ```

- **Obtenir un produit par son SKU :**
  ```sh
  curl "http://localhost:3000/api/products/sku/SKU-001"
  ```

### API Commandes

- **Lister les commandes avec filtres sur le statut et les dates :**
  ```sh
  curl "http://localhost:3000/api/orders?status=paid&from=2025-01-01&to=2025-12-31"
  ```

- **Obtenir une commande par son ID :**
  ```sh
  curl "http://localhost:3000/api/orders/101"
  ```

- **Obtenir une commande par son numéro de commande :**
  ```sh
  curl "http://localhost:3000/api/orders/number/ORD-2025-0001"
  ```
Cette solution complète respecte toutes les exigences du projet, de la structure des fichiers à l'implémentation de chaque fonctionnalité, tout en fournissant un code propre et commenté en français.




Vérifiez les réponses de Gemini, car il peut se tromper.

